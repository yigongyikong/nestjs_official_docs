=====================================================================
https://docs.nestjs.com/middleware
=====================================================================
[Middleware]
- Middleware is a function which is called before the route handler. 
= Middleware는 the route handler before(보다 먼저) called되는 function이다.
- Middleware functions have access to the request and response objects, 
    and the next() middleware function 
    in the application’s request-response cycle. 
= Middleware functions은 application’s request-response cycle(주기)에서
    request and response objects와 the next() middleware function에
    access할 수 있다.
- The next middleware function is commonly denoted 
    by a variable named next.
= The next middleware function은 commonly(일반적)으로 next라고 named된
    variable(변수)로 denoted(표시)된다.
- Nest middleware are, by default, equivalent to express middleware. 
= Nest middleware는 by default(기본적)으로, express(link) middleware와 
    equivalent(동일)하다.
!link : https://expressjs.com/en/guide/using-middleware.html!
- The following description from the official express documentation 
    describes the capabilities of middleware:
= official express documentation의 following description(아래 설명)은
    middleware의 capabilities(기능)을 describes(설명)한다.
- Middleware functions can perform the following tasks:
= Middleware functions은 following tasks를 perform할 수 있다.
    - execute any code.
    = any code를 execute한다.
    - make changes to the request and the response objects.
    = request and response object를 make changes한다.
    - end the request-response cycle.
    = request-response cycle(주기)를 종료(end)한다.
    - call the next middleware function in the stack.
    = stack에서 next middleware function은 call한다.
    - if the current middleware function does not end 
        the request-response cycle, 
        it must call next() to pass control 
        to the next middleware function. 
        Otherwise, the request will be left hanging.
    = current middleware function이 request-response cycle를 end 않으면,
        next middleware function에 control을 pass하도록 
        next()를 call해야 한다.
- You implement custom Nest middleware in either a function, 
    or in a class with an @Injectable() decorator. 
= function 또는 @Injectable() decorator가 with(있는) class에서
    custom Nest middleware를 implement(구현)한다.
- The class should implement the NestMiddleware interface, 
    while the function does not have any special requirements. 
= class는 NestMiddleware interface를 implement해야 하는데,
    while(반면에) function는 any special requirements를 가지지 않는다.
- Let's start by implementing a simple middleware feature 
    using the class method.
= class method를 using해서 simple middleware feature을 
    by implementing하는 것으로 start한다.
- WARNING
    Express and fastify handle middleware differently 
        and provide different method signatures, read more here(link). 
!link : https://docs.nestjs.com/techniques/performance#middleware!
= 주의
    Express와 fastify가 middleware를 differently하게 handle(처리)하고
        different method signatures를 provide한다, here(link)를 더 읽어라.
!link : https://docs.nestjs.com/techniques/performance#middleware!
- ex) logger.middleware.ts
=====================================================================
[Dependency injection]
- Nest middleware fully supports Dependency Injection. 
= Nest middleware는 Dependency Injection을 fully supports한다.
- Just as with providers and controllers, 
    they are able to inject dependencies 
    that are available within the same module. 
= providers 및 controllers와 마찬가지로 same module within(내에)
    available(사용할 수)있는 dependencies을 inject 할 수 있다.
- As usual, this is done through the constructor.
= As usual(평소)처럼, this is constructor를 through(통해) is done(수행)된다.
=====================================================================
[Applying middleware]
- There is no place for middleware in the @Module() decorator. 
= @Module() decorator에 middleware를 위한 place(자리)는 없다.
- Instead, we set them up using the configure() method 
    of the module class. 
= Instead(대신에), module class의 configure() method를 using해서
    them(middleware)를 set up한다.
- Modules that include middleware have to 
    implement the NestModule interface. 
= middleware를 포함한 Modules은 NestModule interface를 implement해야 한다.
- Let's set up the LoggerMiddleware at the AppModule level.
= AppModule level에서 LoggerMiddleware를 set up 해보자.
- ex) app.module.ts
- In the above example we have set up the LoggerMiddleware 
    for the /cats route handlers 
    that were previously defined inside the CatsController. 
= In the above example에서 previously CatsController inside(내부에) 
    defined된 /cats route handler를 LoggerMiddleware에 set up 했다.
- We may also further restrict a middleware 
    to a particular request method 
    by passing an object containing the route path 
    and request method to the forRoutes() method 
    when configuring the middleware. 
= also(또한) the middleware를 configuring할 때 
    route path와 request method를 containing한 object를 
    forRoute() method에 passing해서 특정 request method를
    middleware에 restrict(제한)할 수 있다.
- In the example below, 
    notice that we import the RequestMethod enum 
    to reference the desired request method type.
= In the example below(아래 예에서),
    desired(원하는) request method type을 reference(참조)하기 위해
    RequestMehod enum을 import하는 것을 notice합니다.
- ex) app.module.ts
- HINT
    The configure() method can be made asynchronous 
        using async/await 
        (e.g., you can await completion of an asynchronous operation 
        inside the configure() method body).
- 힌트
    configure() method는 async/await를 using해서 asynchronous으로 
        만들 수 있다. 
        (예로, configure() method body inside에 
            asynchronous operation을 완료될 때까지 await(기다)릴 수 있다.)
- WARNING
    When using the express adapter, 
        the NestJS app will register json and urlencoded 
        from the package body-parser by default. 
    This means if you want to customize that middleware 
        via the MiddlewareConsumer, 
        you need to turn off the global middleware 
        by setting the bodyParser flag to false 
        when creating the application with NestFactory.create().
= 경고
    express adapter를 using할 때, NestJS app은 by default로
        package body-parser에 json과 urlencoded를 register(등록)합니다.
    that middleware를 MiddlewareConsumer를 통해 customize하려면,
        application을 NestFactory.create()로 creating할 때,
        bodyParser flag를 false로 setting해서 global middleware를
        turn off야 한다는 걸 의미한다.
=====================================================================
[Route wildcards]
- Pattern based routes are supported as well. 
= Pattern based routes도 as well(역시) supported(지원)된다.
- For instance, the asterisk is used as a wildcard, 
    and will match any combination of characters:
= 예를 들어, asterisk는 wildcard로써 used되고 combination of characters와
    match(일치)하는 것들이다.
- ex)
    forRoutes({ path: 'ab*cd', method: RequestMethod.ALL });
- The 'ab*cd' route path will match abcd, ab_cd, abecd, and so on. 
= 'ab*cd' route path는 abcd, ab_cd, abecd, 등등과 match한다. 
- The characters ?, +, *, and () may be used in a route path, 
    and are subsets of their regular expression counterparts. 
=  ?, +, *, () 같은 characters는 route path에서 used될 수 있고
    regular express(정규 표현식에) counterparts(대응하는) subsets이다.
- The hyphen (-) and the dot (.) are interpreted literally 
    by string-based paths.
= The hyphen (-) and the dot (.)은 literally(문자 그대로)
    string-based paths로 interpreted(해석)된다.
- WARNING
    The fastify package uses the latest version 
        of the path-to-regexp package, 
        which no longer supports wildcard asterisks *. 
    Instead, you must use parameters (e.g., (.*), :splat*).
= 경고
    fastify package는 no longer(더 이상) wildcard asterisk *를 
        supports하지 않고, 최신 버전의 path-to-regexp package를 사용한다.
=====================================================================
[Middleware consumer]
- The MiddlewareConsumer is a helper class. 
= MiddlewareConsumer는 helper class이다.
- It provides several built-in methods to manage middleware. 
= It(Mid~Con~)는 middleware를 manage하기 위해 
    several built-in methods를 provide한다.
- All of them can be simply chained in the fluent style. 
= them(Mid~Con~)의 전부는 fluent(유창한) style로 
    simply(간단하게) chained(연결)되어 있다.
- The forRoutes() method can take a single string, multiple strings, 
    a RouteInfo object, a controller class 
    and even multiple controller classes. 
= forRoutes() method는 single string, multiple strings, 
    RouteInfo object, controller classes 
    그리고 even(심지어) multiple controller classes를 take(사용)할 수 있다.
- In most cases you'll probably just pass a list of controllers 
    separated by commas. 
= In most cases(대부분의 경우) commas(쉼표)로 separated(구분된)
    list of controller(컨트롤러 목록)을 pass할 것이다.
- Below is an example with a single controller:
= Below는 a single controller의 example이다.
- ex) app.module.ts
- HINT
    The apply() method may either take a single middleware, 
        or multiple arguments to specify multiple middlewares(link).
!link : https://docs.nestjs.com/middleware#multiple-middleware!
= 힌트
    apply() method는 single middleware 또는 multiple arguments(인수)를
        take(사용)해서 multiple middleware를 specify할 수 있다.
=====================================================================
[Excluding routes]
- At times we want to exclude certain routes 
    from having the middleware applied. 
= middleware가 applied되지 않도록 certain routes를 exclude하려는 
    At times(때)가 있다.
- We can easily exclude certain routes with the exclude() method. 
= exclude() method로 certain routes를 easily exclude할 수 있다.
- This method can take a single string, multiple strings, 
    or a RouteInfo object identifying routes to be excluded, 
    as shown below:
= This method는 single string, multiple strings 또는 
    below shown처럼 excluded(제외)할 routes를 identifying하는
    RouteInfo object를 사용할 수 있다.
- ex)
    consumer
        .apply(LoggerMiddleware)
        .exclude(
            { path: 'cats', method: RequestMethod.GET },
            { path: 'cats', method: RequestMethod.POST },
            'cats/(.*)',
        )
        .forRoutes(CatsController);
- HINT
    The exclude() method supports wildcard parameters 
        using the path-to-regexp package.
= 힌트
    exclude() method는 path-to-regexp package를 using해서 
        wildcard parameters를 지원한다.
- With the example above, 
    LoggerMiddleware will be bound to all routes defined 
    inside CatsController except the three passed 
    to the exclude() method.
= above example에서, LoggerMiddleware는 exclude() method에 passed(전달)된
    the three(세가지) 경로를 except(제외)하고 CatsController 내부에 defined된
    all routes를 모두 bound하게 된다.
=====================================================================
[Functional middleware]
- The LoggerMiddleware class we've been using is quite simple. 
= we가 using한 LoggerMiddleware class는 quite simple하다.
- It has no members, no additional methods, and no dependencies. 
= members, additional method, dependencies가 없다.
- Why can't we just define it in a simple function instead of a class? 
= class 대신에 simple function로 it(LoggerMiddleware)를 define할 수 없을까?
- In fact, we can. 
= 사실, 그렇다.
- This type of middleware is called functional middleware. 
= This type의 middleware는 functional middleware로 불린다.
- Let's transform the logger middleware from class-based 
    into functional middleware to illustrate the difference:
= difference를 illustrate(설명)하기 위해 class-based(클래스 기반)에서
    functional middleware로 transform(변환)해 보자.
- ex) logger.middleware.ts
- And use it within the AppModule:
= 그 다음 AppModule 내에서 사용해보라:
- ex) app.module.ts
- HINT
    Consider using the simpler functional middleware alternative 
        any time your middleware doesn't need any dependencies.
= 힌트
    middleware가 any dependencies도 필요하지 않을 any time에도
        simpler functional middleware alternative(대안)을 using할 것을
        Consider해라.    
=====================================================================
[Multiple middleware]
- As mentioned above, in order to bind multiple middleware 
    that are executed sequentially, 
    simply provide a comma separated list inside the apply() method:
= As mentioned above, sequentially(순차적)으로 executed(실행)되는
    multiple middleware를 bind하기 위해서,
    apply() method 내부에 comma로 separated된 list를 단순히 provide하면 된다.
- ex)
    consumer.apply(cors(), helmet(), logger).forRoutes(CatsController);
=====================================================================
[Global middleware]
- If we want to bind middleware to every registered route at once, 
    we can use the use() method that is supplied 
    by the INestApplication instance:
= every registered route는 at once(한번에) middleware를 bind하고 싶다면,
    INestApplication instance로 supplied(제공)되는 
    use() method를 사용할 수 있다.
- ex) main.ts
- HINT
    Accessing the DI container in a global middleware is not possible. 
    You can use a functional middleware instead when using app.use(). 
    Alternatively, you can use a class middleware and consume it 
        with .forRoutes('*') within the AppModule 
        (or any other module).
= 힌트
    global middleware에서 DI container에 Accessing하는 것은 불가능하다.
    app.use()를 using할 때 대신 functional middleware를 use할 수 있다.
    Alternatively(대신에), class middleware를 사용할 수 있고
        it(cla~ mid~)를 AppModule내에서(또는 any other module) 
        .forRoutes('*')로 consume(사용)할 수 있다.
=====================================================================