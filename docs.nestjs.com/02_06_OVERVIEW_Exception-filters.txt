=====================================================================
https://docs.nestjs.com/exception-filters
=====================================================================
[Exception filters]
- Nest comes with a built-in exceptions layer which is responsible for
    processing all unhandled exceptions across an application.
= Nest는 an application across(전체)에서 unhandled(처리되지 않은) exceptions을
    all(모두) processing(처리)하도록 responsible(책임을 부여)한 
    build-in exception layer를 comes with(함께 제공된다).
- When an exception is not handled by your application code,
    it is caught by this layer, which then automatically
    sends an appropriate user-friendly response.
= application code에서 an exception이 handled되지 않으면,
    this layer에서 it(exception)이 caught(포착)되고, 그래서 자동으로 적절한
    user-friendly response를 보낸다.
- Out of the box, this action is performed by a built-in
    global exception filter, which handles exceptions of type
    HttpException (and subclasses of it).
= 즉각적으로, this action은 HttpException type(그리고 it의 subclasses)의 
    exceptions을 handles하는 built-in된 global exception filter에 의해
    performed된다.
- When an exception is unrecognized (is neither HttpException
    nor a class that inherits from HttpException),
    the built-in exception filter generates the following
    default JSON response:
= an exception이 unrecognized된 경우(HttpException도 아니고 HttpException에서
    inherits{상속}하는 class도 아닌), the built-in exception이 following하는
    default JSON response를 generates한다.
- ex)
    {
        "statusCode": 500,
        "message": "Internal server error"
    }
- HINT
    The global exception filter partially supports
        the http-errors library.
    Basically, any thrown exception containing the statusCode
        and message properties will be properly populated
        and sent back as a response (instead of the default
        InternalServerErrorException for unrecognized exceptions).
= 힌트
    global exception filter는 partially http-errors library를 
        supports한다.
    기본적으로, statusCode와 message properties를 containing하는 
        any thrown(던져진) exception은 properly populated(채워)지게 되고
        response로 다시 sent될 것이다.
        (unrecognized exceptions을 대신하기 위한
            default InternalServerErrorException)
=====================================================================
[Throwing standard exceptions]
- Nest provides a built-in HttpException class, exposed from
    the @nestjs/common package.
= Nest는 @nestjs/common 패키지에서 exposed되는,
    built-in HttpException class를 provide한다.
- For typical HTTP REST/GraphQL API based applications,
    it's best practice to send standard HTTP response objects
    when certain error conditions occur.
= typical HTTP REST/GraphQL API를 based한 applications에 대해,
    certain(특정) error conditions이 occur할 때 
    standard HTTP response objects를 send하는 것이 best practice다.
- For example, in the CatsController, we have a findAll() method
    (a GET route handler).
= 예를 들어, CatsController에서, 
    findAll() method(GET route handler)가 있다.
- Let's assume that this route handler throws an exception for
    some reason.
= this route handler는 some reason로 an exception을 throws한다고
    assume(가정)하자.
- To demonstrate this, we'll hard-code it as follows:
= this(위~)를 demonstrate(시연)하기 위해, follows와 같이 hard-code할 것이다.
- ex) cats.controller.ts
    @Get()
    async findAll() {
        throw new HttpException('Forbidden', HttpStatus.FORBIDDEN);
    }
- HINT
    We used the HttpStatus here. 
    This is a helper enum imported from the @nestjs/common package.
= 힌트
    여기에 HttpStatus를 사용했다.
    This(HttpStatus)는 @nestjs/common package에서 
        imported된 helper enum이다.
- When the client calls this endpoint, the response looks like this:
= the client가 this endpoint를 calls할 때, response는 this(아래)와 같다:
    {
        "statusCode": 403,
        "message": "Forbidden"
    }
- The HttpException constructor takes two required arguments 
    which determine the response:
= HttpException constructor는 두 개의 arguments를 사용해 response를 결정한다:
    - The response argument defines the JSON response body. 
        It can be a string or an object as described below.
    = The response argument는 JSON response body를 정의한다.
        below(아래) described(설명)대로 string 또는 object가 될 수 있다.
    - The status argument defines the HTTP status code.
    = The status argument는 HTTP status code를 defines한다.
- By default, the JSON response body contains two properties:
= 기본으로, the JSON response body는 two properties를 포함한다:
    - statusCode: defaults to the HTTP status code provided 
        in the status argument
    = 상태코드: 기본값은 status argument에서 provided된 HTTP status code이다.
    - message: a short description of the HTTP error based on 
        the status
    = 메시지: the status에 based on(기반)한 HTTP error에 대한 짧은 설명
- To override just the message portion of the JSON response body, 
    supply a string in the response argument. 
= JSON response body의 message portion(부분) 만(just) override(재정의)하기
    위해서, response argument에 string을 제공해라.
- To override the entire JSON response body, 
    pass an object in the response argument. 
= entire JSON response body를 override하기 위해서,
    response argument에 object를 pass(전달)한다.
- Nest will serialize the object and return it 
    as the JSON response body.
= Nest는 object를 serialize하고 JSON response body을 return한다.
- The second constructor argument - status - should be 
    a valid HTTP status code. 
= The second constructor argument인- status -는 
    valid한 HTTP status code가 되어야 한다.
- Best practice is to use the HttpStatus enum imported 
    from @nestjs/common.
= Best practice는 @nestjs/common에서 imported된 
    HttpStatus enum을 사용하는 것이다.
- There is a third constructor argument (optional) - options - that 
    can be used to provide an error cause. 
= an error cause을 provide하는 데 사용되는 
    third constructor argument(optional)이 있다.
- This cause object is not serialized into the response object, 
    but it can be useful for logging purposes, 
    providing valuable information about the inner error 
    that caused the HttpException to be thrown.
= This(위~third constructor)은 response object로 serialized되지 않지만,
    logging purposes에 유용할 수 있고, be thrown(던져)진 HttpException을
    causedgks inner error에 대한 valuable information를 providing한다.
- Here's an example overriding the entire response body 
    and providing an error cause:
= error cause(원인)을 providing하고 entire response body를 overriding하는
    example이 여기 있다.
- ex) cats.controller.ts
    @Get()
    async findAll() {
        try {
            await this.service.findAll()
        } catch (error) {
            throw new HttpException({
                status: HttpStatus.FORBIDDEN,
                error: 'This is a custom message',
            }, HttpStatus.FORBIDDEN, {
                cause: error
            });
        }
    }
- Using the above, this is how the response would look:
= 위(above)예를 사용해서, this은 response가 how(어떻게) 보이는 지 표시한다:
- ex)
    {
        "status": 403,
        "error": "This is a custom message"
    }
=====================================================================
[Custom exceptions]
- In many cases, you will not need to write custom exceptions, 
    and can use the built-in Nest HTTP exception, 
    as described in the next section. 
= In many cases, custom(사용자지정) exception을 write할 필요는 없을 것이고,
    built-in Nest HTTP exception을 사용할 수 있다,
    next section에서 설멍할 것이다.
- If you do need to create customized exceptions, it's good practice 
    to create your own exceptions hierarchy, where your custom 
    exceptions inherit from the base HttpException class. 
= customized exception을 create할 필요가 있다면, own exceptions hierarchy를
    create하는 것이 good practice이고, 거기서 your custom exceptions은
    the base HttpException class에 상속된다.
= customized exception을 create할 필요가 있다면, your custom exceptions이
    the base HttpException class에 inherit(상속)되는 own exceptions
    hierarchy를 create하는 게 good practice이다.
- With this approach, Nest will recognize your exceptions, 
    and automatically take care of the error responses. 
= this approach로, Nest는 your exceptions를 recognize하고,
    자동으로 error responses를 처리한다.
- Let's implement such a custom exception:
= 이러한 custom exception을 implement해보자.
- ex) forbidden.exception.ts
    export class ForbiddenException extends HttpException {
        constructor() {
            super('Forbidden', HttpStatus.FORBIDDEN);
        }
    }
- Since ForbiddenException extends the base HttpException, 
    it will work seamlessly with the built-in exception handler, 
    and therefore we can use it inside the findAll() method.
= ForbiddenException이 the base HttpException을 extends하기 때문에,
    built-in(기본 내장된) exception handler로 seamlessly(원활하게)
    work할 것이고, 그래서 findAll() method inside에서 
    it(ForbiddenException)을 사용할 수 있다.
- cats.controller.ts
    @Get()
    async findAll() {
        throw new ForbiddenException();
    }
=====================================================================
[Built-in HTTP exceptions]
- Nest provides a set of standard exceptions that inherit 
    from the base HttpException. 
= Nest는 base HttpException에서 inherit(상속)되는 
    a set of standard exceptions를 provides한다.
- These are exposed from the @nestjs/common package, 
    and represent many of the most common HTTP exceptions:
= These(위~)는 @nestjs/common package에 exposed되고,
    the most common HTTP exceptions를 represent(나타낸)다.
    - BadRequestException
    - UnauthorizedException
    - NotFoundException
    - ForbiddenException
    - NotAcceptableException
    - RequestTimeoutException
    - ConflictException
    - GoneException
    - HttpVersionNotSupportedException
    - PayloadTooLargeException
    - UnsupportedMediaTypeException
    - UnprocessableEntityException
    - InternalServerErrorException
    - NotImplementedException
    - ImATeapotException
    - MethodNotAllowedException
    - BadGatewayException
    - ServiceUnavailableException
    - GatewayTimeoutException
    - PreconditionFailedException
- All the built-in exceptions can also provide both an error cause 
    and an error description using the options parameter:
= All the built-in exceptions는 options parameter를 using하는
    error description과 error cause를 both provide할 수 있다.
- ex) throw new BadRequestException('Something bad happened', { cause: new Error(), description: 'Some error description' })
- Using the above, this is how the response would look:
= above(위 ex)를 사용해서, 아래와 같은 response가 표시된다.
- ex)
    {
        "message": "Something bad happened",
        "error": "Some error description",
        "statusCode": 400,
    }
=====================================================================
[Exception filters]
- While the base (built-in) exception filter can automatically 
    handle many cases for you, you may want full control over 
    the exceptions layer. 
= the base (built-in) exception filter가 자동적으로 many cases를
    handle할 수 있지만, the exception layer over(에 대한) full control을
    원할 수 있다.
- For example, you may want to add logging or use a different JSON 
    schema based on some dynamic factors. 
= 예를 들어, logging을 add하거나 some dynamic factors에 based on한
    different JSON schema를 사용할 수 있다.
- Exception filters are designed for exactly this purpose. 
= Exception filters는 exactly(바로) this purpose을 위해 designed(설계)되었다.
- They let you control the exact flow of control and the content of 
    the response sent back to the client.
= They(위~)는 the exact flow of control과 client로 sent back되는
    the response의 the content를 control하게 한다.
- Let's create an exception filter that is responsible for 
    catching exceptions which are an instance of the HttpException 
    class, and implementing custom response logic for them. 
= the HttpException class의 an instance인 exceptions를 catching(포착)하고,
    for them(이에 대한) custom response를 implementing하는 
    exception filter를 생성한다.
- To do this, we'll need to access the underlying platform Request 
    and Response objects. 
= this(위~)같이 하려면, underlying(기본) platform Request과 Response objects에
    access해야 할 필요가 있다.
- We'll access the Request object so we can pull out the original url 
    and include that in the logging information. 
= the Request object에 access해서 original url을 pull out(추출)하고
    logging information에 include할 수 있다.
- We'll use the Response object to take direct control of 
    the response that is sent, using the response.json() method.
= response.json() method를 using해서, is sent되는 the response을
    direct control하기 위해 Response object를 사용할 것이다.
- ex) http-exception.filter.ts
    import { ExceptionFilter, Catch, ArgumentsHost, HttpException } from '@nestjs/common';
    import { Request, Response } from 'express';

    @Catch(HttpException)
    export class HttpExceptionFilter implements ExceptionFilter {
        catch(exception: HttpException, host: ArgumentsHost) {
            const ctx = host.switchToHttp();
            const response = ctx.getResponse<Response>();
            const request = ctx.getRequest<Request>();
            const status = exception.getStatus();

            response
                .status(status)
                .json({
                    statusCode: status,
                    timestamp: new Date().toISOString(),
                    path: request.url,
                });
        }
    }
- HINT
    All exception filters should implement the generic 
        ExceptionFilter<T> interface. 
    This requires you to provide the catch (exception: T, 
        host: ArgumentsHost) method with its indicated signature. 
    T indicates the type of the exception.
= 힌트
    All exception filters는 the generic ExceptionFilter<T> interface를
        implement해야 한다.
    This(이렇게 하려면) indicated된 signature과 함께 
        "catch(exception: T, host: ArgumentsHost)" method를 
        provide할 필요가 있다.
    T는 the exception의 type을 indicates(나타)낸다.
- WARNING
    If you are using @nestjs/platform-fastify you can use 
        response.send() instead of response.json(). 
    Don't forget to import the correct types from fastify.
= 경고
    @nestjs/platform-fastify를 using하는 경우 response.json() 대신
        response.send()를 사용할 수 있다.
    fastify에서 correct types를 import하는 것을 잊지마라.
- The @Catch(HttpException) decorator binds the required metadata 
    to the exception filter, telling Nest that this particular filter 
    is looking for exceptions of type HttpException and nothing else.
= @Catch(HttpException) decorator는 required한 metadata를
    exception filter에 binds하여 Nest에 this particular filter가
    type HttpException and nothing else(HttpException 유형의)
    exception만 찾고 있음을 telling한다.
- The @Catch() decorator may take a single parameter, 
    or a comma-separated list. 
= The @Catch() decorator는 single parameter 또는 comma-separated list을
    사용할 수 있다.
- This lets you set up the filter for several types of exceptions 
    at once.
= This(이를 통해) at once(한번에) several types의 exception에 대한
    filter를 set up 하게 할 수 있다.
=====================================================================
[Arguments host]
- Let's look at the parameters of the catch() method. 
- The exception parameter is the exception object currently 
    being processed. 
- The host parameter is an ArgumentsHost object. 
- ArgumentsHost is a powerful utility object that we'll examine 
    further in the execution context chapter*. 
- In this code sample, we use it to obtain a reference to 
    the Request and Response objects that are being passed to 
    the original request handler (in the controller where 
    the exception originates). 
- In this code sample, we've used some helper methods 
    on ArgumentsHost to get the desired Request and Response objects. 
- Learn more about ArgumentsHost here.
- *The reason for this level of abstraction is that ArgumentsHost 
    functions in all contexts (e.g., the HTTP server context 
    we're working with now, but also Microservices and WebSockets). 
- In the execution context chapter we'll see how we can access 
    the appropriate underlying arguments for any execution 
    context with the power of ArgumentsHost and its helper functions. 
- This will allow us to write generic exception filters 
    that operate across all contexts.
=====================================================================
[Binding filters]
- Let's tie our new HttpExceptionFilter to the CatsController's 
    create() method.
- ex) cats.controller.ts
    @Post()
    @UseFilters(new HttpExceptionFilter())
    async create(@Body() createCatDto: CreateCatDto) {
        throw new ForbiddenException();
    }
- HINT
    The @UseFilters() decorator is imported 
        from the @nestjs/common package.
- We have used the @UseFilters() decorator here. 
- Similar to the @Catch() decorator, it can take a single filter 
    instance, or a comma-separated list of filter instances. 
- Here, we created the instance of HttpExceptionFilter in place.
- Alternatively, you may pass the class (instead of an instance), 
    leaving responsibility for instantiation to the framework, 
    and enabling dependency injection.
- ex) cats.controller.ts
    @Post()
    @UseFilters(HttpExceptionFilter)
    async create(@Body() createCatDto: CreateCatDto) {
        throw new ForbiddenException();
    }
- HINT
    Prefer applying filters by using classes instead of instances 
        when possible. 
    It reduces memory usage since Nest can easily reuse instances of 
        the same class across your entire module.
- In the example above, the HttpExceptionFilter is applied only 
    to the single create() route handler, making it method-scoped. 
- Exception filters can be scoped at different levels: 
    method-scoped, controller-scoped, or global-scoped. 
- For example, to set up a filter as controller-scoped, 
    you would do the following:
- ex) cats.controller.ts
    @UseFilters(new HttpExceptionFilter())
    export class CatsController {}
- This construction sets up the HttpExceptionFilter 
    for every route handler defined inside the CatsController.
- To create a global-scoped filter, you would do the following:
- ex) main.ts
    async function bootstrap() {
        const app = await NestFactory.create(AppModule);
        app.useGlobalFilters(new HttpExceptionFilter());
        await app.listen(3000);
    }
    bootstrap();
- WARNING
    The useGlobalFilters() method does not set up filters 
        for gateways or hybrid applications.
- Global-scoped filters are used across the whole application, 
    for every controller and every route handler. 
- In terms of dependency injection, global filters registered 
    from outside of any module (with useGlobalFilters() 
    as in the example above) cannot inject dependencies 
    since this is done outside the context of any module. 
- In order to solve this issue, you can register a global-scoped 
    filter directly from any module using the following construction:
- ex) app.module.ts
    import { Module } from '@nestjs/common';
    import { APP_FILTER } from '@nestjs/core';

    @Module({
        providers: [
            {
                provide: APP_FILTER,
                useClass: HttpExceptionFilter,
            },
        ],
    })
    export class AppModule {}
- HINT
    When using this approach to perform dependency injection for 
        the filter, note that regardless of the module where 
        this construction is employed, the filter is, in fact, global. 
    Where should this be done? Choose the module where the filter 
        (HttpExceptionFilter in the example above) is defined. 
    Also, useClass is not the only way of dealing with custom provider 
        registration. Learn more here.
- You can add as many filters with this technique as needed; 
    simply add each to the providers array.
=====================================================================
[Catch everything]
- In order to catch every unhandled exception (regardless of 
    the exception type), leave the @Catch() decorator's parameter 
    list empty, e.g., @Catch().
- In the example below we have a code that is platform-agnostic 
    because it uses the HTTP adapter to deliver the response, 
    and doesn't use any of the platform-specific objects 
    (Request and Response) directly:
- ex)
    import {
        ExceptionFilter,
        Catch,
        ArgumentsHost,
        HttpException,
        HttpStatus,
    } from '@nestjs/common';
    import { HttpAdapterHost } from '@nestjs/core';

    @Catch()
    export class AllExceptionsFilter implements ExceptionFilter {
        constructor(private readonly httpAdapterHost: HttpAdapterHost) {}

        catch(exception: unknown, host: ArgumentsHost): void {
            // In certain situations `httpAdapter` might not be available in the
            // constructor method, thus we should resolve it here.
            const { httpAdapter } = this.httpAdapterHost;

            const ctx = host.switchToHttp();

            const httpStatus =
                exception instanceof HttpException
                ? exception.getStatus()
                : HttpStatus.INTERNAL_SERVER_ERROR;

            const responseBody = {
                statusCode: httpStatus,
                timestamp: new Date().toISOString(),
                path: httpAdapter.getRequestUrl(ctx.getRequest()),
            };

            httpAdapter.reply(ctx.getResponse(), responseBody, httpStatus)                                                                                                                                                                                                                         ;
        }
    }
- WARNING
    When combining an exception filter that catches everything 
        with a filter that is bound to a specific type, 
        the "Catch anything" filter should be declared first 
        to allow the specific filter to correctly handle the bound type.
=====================================================================
[Inheritance]
- Typically, you'll create fully customized exception filters 
    crafted to fulfill your application requirements. 
- However, there might be use-cases when you would like to simply 
    extend the built-in default global exception filter, 
    and override the behavior based on certain factors.
- In order to delegate exception processing to the base filter, 
    you need to extend BaseExceptionFilter and call the inherited 
    catch() method.
- ex) all-exceptions.filter.ts
    import { Catch, ArgumentsHost } from '@nestjs/common';
    import { BaseExceptionFilter } from '@nestjs/core';

    @Catch()
    export class AllExceptionsFilter extends BaseExceptionFilter {
        catch(exception: unknown, host: ArgumentsHost) {
            super.catch(exception, host);
        }
    }
- WARNING
    Method-scoped and Controller-scoped filters that extend the 
        BaseExceptionFilter should not be instantiated with new. 
    Instead, let the framework instantiate them automatically.
- The above implementation is just a shell demonstrating the approach. 
- Your implementation of the extended exception filter would include 
    your tailored business logic (e.g., handling various conditions).
- Global filters can extend the base filter. 
    This can be done in either of two ways.
- The first method is to inject the HttpAdapter reference 
    when instantiating the custom global filter:
- ex)
    async function bootstrap() {
        const app = await NestFactory.create(AppModule);

        const { httpAdapter } = app.get(HttpAdapterHost);
        app.useGlobalFilters(new AllExceptionsFilter(httpAdapter));

        await app.listen(3000);
    }
    bootstrap();
- The second method is to use the APP_FILTER token as shown here.
=====================================================================