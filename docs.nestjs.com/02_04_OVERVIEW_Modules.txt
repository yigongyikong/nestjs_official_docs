=====================================================================
https://docs.nestjs.com/modules
=====================================================================
[Modules]
- A module is a class annotated with a @Module() decorator. 
= module은 @Module() decorator로 annotated(주석이 달려진)된 class를 말한다.
- The @Module() decorator provides metadata 
    that Nest makes use of to organize the application structure.
= @Module() decorator는 Nest가 application structure를 구성하는 데 
    사용하는 metadata를 제공한다.
- Each application has at least one module, a root module. 
= 각 application은 at least(최소) 하나의 module인 root module을 가진다.
- The root module is the starting point 
    Nest uses to build the application graph - 
    the internal data structure Nest uses to resolve module 
    and provider relationships and dependencies. 
= root module은 Nest가 application graph를 build하는데 use하는
    starting point(시작점)이다 
    - Nest가 module과 provider relationships 및 dependencies을
    resolve하는데 uses하는 internal data structure이다.
- While very small applications may theoretically have 
    just the root module, this is not the typical case. 
= very small application은 theoretically root module만 가질 수 있지만,
    this(위~)은 typical(일반적인) case는 아니다.
- We want to emphasize that modules are strongly recommended 
    as an effective way to organize your components. 
= components를 organize(구성)하는 effective(효과적인) way(방법)으로
    modules이 strongly하게 recommended된다는 점을 emphasize(강조)하고 싶다.
- Thus, for most applications, 
    the resulting architecture will employ multiple modules, 
    each encapsulating a closely related set of capabilities.
= Thus(따라서), most application에서, resulting architecture는
    each(각각) closely(밀접하게) related(관련된) capabilities(기능)의 set을
    encapsulating(캡슐화)하는 multiple modules(여러 모듈)을 사용한다.
- The @Module() decorator takes a single object 
    whose properties describe the module:
= @Module() decorator는 properties이 module을 describe(설명)하는 
    single object(단일 객체)를 사용한다.
- providers
    the providers that will be instantiated by the Nest injector 
    and that may be shared at least across this module
= providers
    Nest injector에 의해 instantiated(초기화)되어 at least(적어도) 
    this module에서 공유될 수 있는 provider
- controllers
    the set of controllers defined in this module 
    which have to be instantiated
= controller
    instantiated되어야하는 this module에 defined(정의)된 controller set
- imports
    the list of imported modules that export the providers 
    which are required in this module
= imports
    this module에 required(요구)되는 providers를 export하고 
    imported된 modules 리스트
- exports
    the subset of providers that are provided by this module 
    and should be available in other modules which import this module. 
    You can use either the provider itself or just its token 
    (provide value)
= exports
    this module에 의해 provided(제공되)는 providers의 subset은
        this module을 import(가져오는) other module에서 available해야 한다.
    provider itself(그 자체) 또는 its(해당) token(provide value)만으로
        사용할 수 있다. 
- The module encapsulates providers by default. 
= The module은 by default(기본적으로) providers를 encapsulates한다.
- This means that it's impossible to inject providers 
    that are neither directly part of the current module 
    nor exported from the imported modules. 
= current module의 directly part도 아니고 imported(가져온) modules에서
    exported(내보낸) providers도 inject하는 게 impossible하다는 것을 means한다.
- Thus, you may consider the exported providers 
    from a module as the module's public interface, or API.
= Thus(따라서), module에서 exported된 providers를
    module's public interface 또는 API로 consider할 수 있어야 한다.
=====================================================================
[Feature modules]
- The CatsController and CatsService belong to 
    the same application domain. 
= CatsController 와 CatsService는 동일한 application domain에 속한다.
- As they are closely related, 
    it makes sense to move them into a feature module. 
= they(CatsCon~과 CatsSer~)은 closely(밀접하게) 관련되어 있어서,
    feature module로 them(위 they)을 move하는 게 맞다.
- A feature module simply organizes code 
    relevant for a specific feature, 
    keeping code organized and establishing clear boundaries. 
= feature module은 simply(단순히) specific feature과 관련된 code를 구성해서,
    code가 clear(명확한) boundaries(경계)를 keeping한다.
- This helps us manage complexity and develop with SOLID principles, 
    especially as the size of the application and/or team grow.
= This(위~)는 especially application 또는 teamd의 size가 grow(성장)함에 따라,
    complexity을 manage하고 SOLID principles에 따라 develop하는데 도움이 된다.
- To demonstrate this, we'll create the CatsModule.
= this를 demonstrate(시연)하기 위해, CatsModule을 생성할 것이다.
- ex) cats/cats.module.ts
- HINT
    To create a module using the CLI, 
    simply execute the $ nest g module cats command.
= 힌트
    CLI를 using해서 module을 생성하기 위해서,
    simply(간단히) "$ nest g module cats" command(명령어)를 실행하면 된다.
- Above, we defined the CatsModule in the cats.module.ts file, 
    and moved everything related to this module into the cats directory. 
= 위 예시처럼, "cats.module.ts" 파일에 CatsModule을 defined(정의)했고,
    cats directory에 this module과 관련된 것들이 옮겨진다.
- The last thing we need to do is import this module 
    into the root module 
    (the AppModule, defined in the app.module.ts file).
= The last thing(마지막으로) need to do(해야할)일은
    root module(app.module.ts에 정의된 AppModule)에 
    this module을 import하면된다.
- ex) app.module.ts
- Here is how our directory structure looks now:
= Here에 directory structure는 looks now(아래와 같)다.
-   src
    -   cats
        -   dto
            create-cat.dto.ts
        -   interfaces
            cat.interface.ts
        cats.controller.ts
        cats.module.ts
        cats.service.ts
    -   app.module.ts
    -   main.ts
=====================================================================
[Shared modules]
- In Nest, modules are singletons by default, 
    and thus you can share the same instance of any provider 
    between multiple modules effortlessly.
= Nest에서, module은 by default(기본으로) singletons이고,
    그래서 multiple module 간에 any provider의 same(동일)한 instance를
    effortlessly(쉽게) share(공유)할 수 있다.
- Every module is automatically a shared module. 
= Every module은 automatically으로 shared module이다.
- Once created it can be reused by any module. 
= 일단 it(module)을 생성하면 any module에서도 재사용할 수 있다.
- Let's imagine that we want to share an instance 
    of the CatsService between several other modules. 
= several othoer modules between(간)에 CatsService의 instance를 
    공유하고 싶다고 상상해보자.
- In order to do that, 
    we first need to export the CatsService provider 
    by adding it to the module's exports array, as shown below:
= In order to do that(그렇게 하기 위해서), first(먼저) as shown below(아래),
    ex)와 같은 module's export array에 it(위 CatsS~ pro~)에 adding해서 
    CatsService provider를 export할 필요가 있다.
- ex) cats.module.ts
- Now any module 
    that imports the CatsModule has access to the CatsService 
    and will share the same instance with all other modules 
    that import it as well.
= Now(이제) CatsModule을 imports하는 any module도 CatsService에 
    access(접근) 가능하고 it(CatsService)를 as well(또한) import하는
    all other modules과 same instance를 share할 것이다.
=====================================================================
[Module re-exporting]
- As seen above, Modules can export their internal providers. 
= As seen above, Modules는 internal providers를 export할 수 있다.
- In addition, they can re-export modules that they import. 
= In addition(또한), they import한 modules을 re-export할 수 있다.
- In the example below, the CommonModule is both imported into 
    and exported from the CoreModule, 
    making it available for other modules which import this one.
= In the example below(아래 예제에서), CommonModule은
    CoreModeule로 imported into(가져)와지고 and exported from(내보)내서,
    this one(CommonModule)을 import한 other modules에서 it(CommonModule)을
    available(이용 가능하게) 한다.
- ex) @Module({
        imports: [CommonModule],
        exports: [CommonModule],
    })
    export class CoreModule {}
=====================================================================
[Dependency injection]
- A module class can inject providers as well 
    (e.g., for configuration purposes):
= module class는 providers도 as well(역시) inject할 수 있다.
    (예시, configuration(구성) 목적용)
- ex) cats.module.ts
- However, module classes themselves cannot be injected 
    as providers due to circular dependency(below link).
        !https://docs.nestjs.com/fundamentals/circular-dependency!
= However(하지만), module classes는 themselves(그 자체)는 
    circular dependency(순환 종속성)으로 due to(인한) providers로
    inject할 수 없다.
=====================================================================
[Global modules]
- If you have to import the same set of modules everywhere, 
    it can get tedious. 
= everywhere(모든 곳에) the same set of modules을 import 해야한다면, 
    it can get tedious(지겨울 수 있)다.
- Unlike in Nest, Angular providers are registered in the global scope. 
= Nest와 달리, Angular providers는 global scope에 are registered(동록)되었다.
- Once defined, they're available everywhere. 
= Once(일단) defined되면, they(provider)는 everywhere 곳에서 available하다.
- Nest, however, encapsulates providers inside the module scope. 
= however, Nest는 module scope 내에 있는 providers를 encapsulates한다.
- You aren't able to use a module's providers elsewhere 
    without first importing the encapsulating module.
= the encapsulating module을 first(먼저) importing하지 않고 
    elsewhere(다른 곳)에서 module's providers를 use할 수 없다.
- When you want to provide a set of providers 
    which should be available everywhere out-of-the-box 
    (e.g., helpers, database connections, etc.), 
    make the module global with the @Global() decorator.
= everywhere에서 out-of-the-box(즉시) should be available(사용 가능해야 하는)
    a set of providers(예, helpers, database connections, 등)를
    provide하길 원한다면, @Global() decorator를 global(전역)으로 만들어야 한다.
- ex)   import { Module, Global } from '@nestjs/common';
        import { CatsController } from './cats.controller';
        import { CatsService } from './cats.service';

        @Global()
        @Module({
            controllers: [CatsController],
            providers: [CatsService],
            exports: [CatsService],
        })
        export class CatsModule {}
- The @Global() decorator makes the module global-scoped. 
= @Global() decorator는 global-scoped(전역-범위)로 module을 생성한다.
- Global modules should be registered only once, 
    generally by the root or core module. 
= Global modules은 generally(일반적으로) root 또는 core module에, 
    once(일단) only(한번) should be registered(등록되어야 한)다.
- In the above example, the CatsService provider will be ubiquitous, 
    and modules that wish to inject the service will not need to 
    import the CatsModule in their imports array.
= In the above example(위 예제에서), CatsService provider는 ubiquitous가 
    될 것이고, service를 inject하려는 module은 imports array에 CatsModule을
    import할 필요는 없어집니다.
- HINT
    Making everything global is not a good design decision. 
    Global modules are available 
        to reduce the amount of necessary boilerplate. 
    The imports array is generally the preferred way 
        to make the module's API available to consumers.
= 힌트
    everything(모든 것)을 global로 Making것은 좋지 않은 design 결정이다.
    Global modules은 necessary한 boilerplate(상용구)의 the amount of을 
        reduce(줄이는)데 available(사용가능)하다.
    The imports array은 generally(일반적으로) consumers에게
        module's API를 available하는 게 preferred way이다.
=====================================================================
[Dynamic modules]
- The Nest module system includes a powerful feature 
    called dynamic modules. 
= Nest module system은 dynamic module이라는 powerful feature를 포함한다.
- This feature enables you to easily create customizable modules 
    that can register and configure providers dynamically. 
= 이 feature은 dynamically으로 providers를 register 및 configure할수 있는 
    customizable module을 easily create할 수 있게 할 수 있다.
- Dynamic modules are covered extensively here. 
= Dynamic modules은 here(아래 링크)에서 extensively(폭 넒게) covered(다룹)니다.
    !https://docs.nestjs.com/fundamentals/dynamic-modules!
- In this chapter, 
    we'll give a brief overview to complete the introduction to modules.
= 이번 장에서, modules에 대해 introduction를 complete하는 
    brief overview 제공합니다.
- Following is an example of a dynamic module definition 
    for a DatabaseModule:
= 다음 예제(Following)는 DatabaseModule에 대한 
    dynamic module definition의 example이다.
- ex)   import { Module, DynamicModule } from '@nestjs/common';
        import { createDatabaseProviders } from './database.providers';
        import { Connection } from './connection.provider';

        @Module({
            providers: [Connection],
        })
        export class DatabaseModule {
            static forRoot(entities = [], options?): DynamicModule {
                const providers = createDatabaseProviders(options, entities);
                return {
                    module: DatabaseModule,
                    providers: providers,
                    exports: providers,
                };
            }
        }
- HINT
    The forRoot() method may return a dynamic module 
        either synchronously or asynchronously (i.e., via a Promise).
= 힌트
    forRoot() method는 synchronously 또는 asynchronously(Promise로)으로
        dynamic module을 return할 수 있다.
- This module defines the Connection provider by default 
    (in the @Module() decorator metadata), 
    but additionally - depending on the entities and options objects 
    passed into the forRoot() method - exposes a collection 
    of providers, for example, repositories. 
= This module은 기본적으로 Connection provider을 정의하고
    (@Module() decorator), 하지만 추가적으로-forRoot() method에 전달된 
    entities 및 option objects에 기안해서- 예를 들어 repositories 처럼
    providers의 collection을 exposes한다.
- Note that the properties returned by the dynamic module extend 
    (rather than override) the base module metadata defined 
    in the @Module() decorator. 
= the dynamic module에 의해 returned된 properties(속성)은
    @Module() decorator에서 defined된 base(기본) module metadata를
    extend한다(override 보단)
- That's how both the statically declared Connection provider 
    and the dynamically generated repository providers 
    are exported from the module.
= That은 statically declared(선언)된 Connection provider와 
    dynamically generated repositories providers가 둘다(both)
    module로 부터 exported된다.
- If you want to register a dynamic module in the global scope, 
    set the global property to true.
= global scope에 dynamic module을 want to register(등록)하고 싶다면, 
    global property를 true로 set(설정)해라.
- ex)   {
            global: true,
            module: DatabaseModule,
            providers: providers,
            exports: providers,
        }
- WARNING
    As mentioned above, making everything global 
        is not a good design decision.
= 경고
    As mentioned above(위에서 언급했듯이), 
        everything(모든 것)을 global로 making하는 것은 좋은 design 결정이 아니다.
- The DatabaseModule can be imported and configured 
    in the following manner:
= DatabaseModule은 following manner(아래 예제 방식)으로 
    configured하고 imported 할 수 있다.
- ex)   import { Module } from '@nestjs/common';
        import { DatabaseModule } from './database/database.module';
        import { User } from './users/entities/user.entity';

        @Module({
            imports: [DatabaseModule.forRoot([User])],
        })
        export class AppModule {}
- If you want to in turn re-export a dynamic module, 
    you can omit the forRoot() method call in the exports array:
= dynamic module을 in turn(차례로) re-export(다시 내보내)고 싶다면,
    exports array에서 forRoot() method call을 omit 할 수 있다.
- ex)   import { Module } from '@nestjs/common';
        import { DatabaseModule } from './database/database.module';
        import { User } from './users/entities/user.entity';

        @Module({
            imports: [DatabaseModule.forRoot([User])],
            exports: [DatabaseModule],
        })
        export class AppModule {}
- The Dynamic modules chapter covers this topic in greater detail, 
    and includes a working example.
= Dynamic modules(link1) chapter는 this topic(이 주제)에 대해 
    greater(훨씬 더) detail(자세하)게 cover(다루)고,
    working(동작)하는 example(예제)(link2)를 include한다.
    !link1 : https://docs.nestjs.com/fundamentals/dynamic-modules!
    !link2 : https://github.com/nestjs/nest/tree/master/sample/25-dynamic-modules!
- HINT
    Learn how to build highly customizable dynamic modules 
        with the use of ConfigurableModuleBuilder here(link) 
        in this chapter.
    !https://docs.nestjs.com/fundamentals/dynamic-modules#configurable-module-builder!
= 힌트
    in this chapter에서 ConfigurableModuleBuilder를 with the use(사용하여) 
        highly(고도로) customizable된 dynamic modules을 build하는지 배워보라.
=====================================================================